---
title: "supabase + GraphQL + Next.js ã§èªè¨¼ã¨ãƒªã‚½ãƒ¼ã‚¹ã®æ¨©é™ã‚’è¨­å®šã™ã‚‹"
emoji: "ðŸ“‘"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: []
published: false
---

â€»ã€€æ›¸ãã‹ã‘ã§ã™

- ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å ´æ‰€

https://github.com/SoraKumo001/supabase-test01

# supabase ã¨ GraphQL ã¨èªè¨¼

supabase ã¯ãƒ†ãƒ¼ãƒ–ãƒ«ã®æ§‹é€ ã«åˆã‚ã›ã¦ GraphQL ã‚¹ã‚­ãƒ¼ãƒžãŒè‡ªå‹•ç”Ÿæˆã•ã‚Œã€ãã‚Œã‚’åˆ©ç”¨ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ„ã‚€ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ãŸã ã—ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆã‚„èªè¨¼æ©Ÿèƒ½ã¯ GraphQL ã‚’é€šã—ã¦ã¯å®Ÿè£…ã•ã‚Œã¦ãŠã‚‰ãšã€ãã®éƒ¨åˆ†ã ã‘ã¯ RestAPI ã‚’ç”¨ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€GraphQL ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒžã¯ public ã®ã¿ã®ãŸã‚ã€auth é…ä¸‹ã«ã‚ã‚‹ãƒ¦ãƒ¼ã‚¶æƒ…å ±ã¯ GraphQL ä¸Šã§ã¯é–¢é€£ä»˜ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã®å•é¡Œã«ã†ã¾ãå¯¾å‡¦ã—ã¦ã„ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

# ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºã§ç”¨æ„ã™ã‚‹ã‚‚ã®

https://github.com/supabase/cli

ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºã§å¿…è¦ã¨ãªã‚Šã¾ã™ã€‚

# supabase-cli ã®åˆæœŸè¨­å®š

```sh
supabase init
supabase start
```

ã“ã‚Œã§ supabase ãŒèµ·å‹•ã§ãã¾ã™ã€‚supabase-cli ã‚’ä½¿ã†å ´åˆã®æ³¨æ„ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚å¤–éƒ¨ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªç’°å¢ƒã§ã¯çµ¶å¯¾ã«ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚jwt ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãŒ`super-secret-jwt-token-with-at-least-32-characters-long`ã¨ã„ã†å†…å®¹ã§æ±ºã‚æ‰“ã¡ã«ãªã£ã¦ã„ã‚‹ã®ã§ã€å¤–ã«å‡ºã—ãŸã‚‰ä¸€çž¬ã§ã‚¯ãƒ©ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚

# ç”¨æ„ã‚’æŽ¨å¥¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«

`supabase init`ã§`supabase`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒä½œæˆã•ã‚Œã¾ã™ã€‚ãã®ä¸­ã«ç”¨æ„ã—ã¦ãŠãã¨è‰¯ã„ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚

- supabase/seed.sql

```sql
drop extension if exists pg_graphql;
create extension if not exists pg_graphql;
select graphql.rebuild_schema();

create or replace function graphql.build_update(
    ast jsonb,
    variable_definitions jsonb = '[]',
    variables jsonb = '{}',
    parent_type text = null,
    parent_block_name text = null
)
    returns text
    language plpgsql
as $$
declare
    result text;

    block_name text = graphql.slug();

    field_rec graphql.field = f
        from
            graphql.field f
        where
            f.name = graphql.name_literal(ast) and f.meta_kind = 'Mutation.update';

    filter_arg jsonb = graphql.get_arg_by_name('filter',  graphql.jsonb_coalesce((ast -> 'arguments'), '[]'));
    where_clause text = graphql.where_clause(filter_arg, field_rec.entity, block_name, variables, variable_definitions);
    returning_clause text;

    arg_at_most graphql.field = field from graphql.field where parent_arg_field_id = field_rec.id and meta_kind = 'AtMostArg';
    at_most_clause text = graphql.arg_clause(
        'atMost',
        (ast -> 'arguments'),
        variable_definitions,
        field_rec.entity,
        arg_at_most.default_value
    );

    arg_set graphql.field = field from graphql.field where parent_arg_field_id = field_rec.id and meta_kind = 'UpdateSetArg';
    allowed_columns graphql.field[] = array_agg(field) from graphql.field where parent_arg_field_id = arg_set.id and meta_kind = 'Column';
    set_arg_ix int = graphql.arg_index(arg_set.name, variable_definitions);
    set_arg jsonb = graphql.get_arg_by_name(arg_set.name, graphql.jsonb_coalesce(ast -> 'arguments', '[]'));
    set_clause text;
begin

    if set_arg is null then
        perform graphql.exception('missing argument "set"');
    end if;

    if graphql.is_variable(set_arg -> 'value') then
        -- `set` is variable
        select
            string_agg(
                format(
                    '%I = ($%s::jsonb ->> %L)::%s',
                    case
                        when ac.column_name is not null then ac.column_name
                        else graphql.exception_unknown_field(x.key_, ac.type_)
                    end,
                    graphql.arg_index(
                        graphql.name_literal(set_arg -> 'value'),
                        variable_definitions
                    ),
                    x.key_,
                    ac.column_type
                ),
                ', '
            )
        from
            jsonb_each(variables -> graphql.name_literal(set_arg -> 'value')) x(key_, val)
            left join unnest(allowed_columns) ac
                on x.key_ = ac.name
        into
            set_clause;

    else
        -- Literals and Column Variables
        select
            string_agg(
                case
                    when graphql.is_variable(val -> 'value') then format(
                        '%I = ($%s)::%s',
                        case
                            when ac.meta_kind = 'Column' then ac.column_name
                            else graphql.exception_unknown_field(graphql.name_literal(val), field_rec.type_)
                        end,
                        graphql.arg_index(
                            (val -> 'value' -> 'name' ->> 'value'),
                            variable_definitions
                        ),
                        ac.column_type

                    )
                    else format(
                        '%I = (%L)::%s',
                        case
                            when ac.meta_kind = 'Column' then ac.column_name
                            else graphql.exception_unknown_field(graphql.name_literal(val), field_rec.type_)
                        end,
                        graphql.value_literal(val),
                        ac.column_type
                    )
                end,
                ', '
            )
        from
            jsonb_array_elements(set_arg -> 'value' -> 'fields') arg_cols(val)
            left join unnest(allowed_columns) ac
                on graphql.name_literal(arg_cols.val) = ac.name
        into
            set_clause;

    end if;

    returning_clause = (
        select
            format(
                'jsonb_build_object( %s )',
                string_agg(
                    case
                        when top_fields.name = '__typename' then format(
                            '%L, %L',
                            graphql.alias_or_name_literal(top.sel),
                            field_rec.type_
                        )
                        when top_fields.name = 'affectedCount' then format(
                            '%L, %s',
                            graphql.alias_or_name_literal(top.sel),
                            'count(1)'
                        )
                        when top_fields.name = 'records' then (
                            select
                                format(
                                    '%L, coalesce(jsonb_agg(jsonb_build_object( %s )), jsonb_build_array())',
                                    graphql.alias_or_name_literal(top.sel),
                                    string_agg(
                                        format(
                                            '%L, %s',
                                            graphql.alias_or_name_literal(x.sel),
                                            case
                                                when nf.column_name is not null and nf.column_type = 'bigint'::regtype then format('(%I.%I)::text', block_name, nf.column_name)
                                                when nf.column_name is not null then format('%I.%I', block_name, nf.column_name)
                                                when nf.meta_kind = 'Function' then format('%I(%I)', nf.func, block_name)
                                                when nf.name = '__typename' then format('%L', top_fields.type_)
                                                when nf.local_columns is not null and nf.meta_kind = 'Relationship.toMany' then graphql.build_connection_query(
                                                    ast := x.sel,
                                                    variable_definitions := variable_definitions,
                                                    variables := variables,
                                                    parent_type := top_fields.type_,
                                                    parent_block_name := block_name
                                                )
                                                when nf.local_columns is not null and nf.meta_kind = 'Relationship.toOne' then graphql.build_node_query(
                                                    ast := x.sel,
                                                    variable_definitions := variable_definitions,
                                                    variables := variables,
                                                    parent_type := top_fields.type_,
                                                    parent_block_name := block_name
                                                )
                                                else graphql.exception_unknown_field(graphql.name_literal(x.sel), top_fields.type_)
                                            end
                                        ),
                                        ','
                                    )
                                )
                            from
                                lateral jsonb_array_elements(top.sel -> 'selectionSet' -> 'selections') x(sel)
                                left join graphql.field nf
                                    on top_fields.type_ = nf.parent_type
                                    and graphql.name_literal(x.sel) = nf.name
                            where
                                graphql.name_literal(top.sel) = 'records'
                        )
                        else graphql.exception_unknown_field(graphql.name_literal(top.sel), field_rec.type_)
                    end,
                    ', '
                )
            )
        from
            jsonb_array_elements(ast -> 'selectionSet' -> 'selections') top(sel)
            left join graphql.field top_fields
                on field_rec.type_ = top_fields.parent_type
                and graphql.name_literal(top.sel) = top_fields.name
    );

    result = format(
        'with updated as (
            update %s as %I
            set %s
            where %s
            returning *
        ),
        total(total_count) as (
            select
                count(*)
            from
                updated
        ),
        req(res) as (
            select
                %s
            from
                updated as %I
        ),
        wrapper(res) as (
            select
                case
                    when total.total_count > %s then graphql.exception($a$update impacts too many records$a$)::jsonb
                    else req.res
                end
            from
                total
                left join req
                    on true
            limit 1
        )
        select
            res
        from
            wrapper;',
        field_rec.entity,
        block_name,
        set_clause,
        where_clause,
        coalesce(returning_clause, 'null'),
        block_name,
        at_most_clause
    );

    return result;
end;
$$;
```

æœ¬æ¥åˆæœŸãƒ‡ãƒ¼ã‚¿ã‚’å…¥ã‚Œã‚‹ãŸã‚ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ãŒã€ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã« GraphQL ã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã™ã‚‹ãŸã‚ã«å¿…è¦ã§ã™ã€‚`supabase start`ã‚„`supabase db reset`ã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½œæˆã—ãŸéš›ã«ã€ä¸€è¦‹ pg_graphql ã®æ‹¡å¼µæ©Ÿèƒ½ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã‚‹ã®ã§ã™ãŒã€å†èµ·å‹•ã—ãªã„ã¨ä½¿ãˆã¾ã›ã‚“ã€‚ã¾ãŸã€`graphql.rebuild_schema()`ã¯ãƒ‡ãƒ¼ãƒ–ãƒ«ã®æ§‹é€ ã‚’å¤‰æ›´ã™ã‚‹ãŸã³ã«å¿…è¦ã«ãªã‚Šã¾ã™ã€‚

ã¾ãŸã€`graphql.build_update`ã‚’ä¸Šæ›¸ãã—ã¦æ›¸ãæ›ãˆã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚’ã‚„ã‚‰ãªã„ã¨ GraphQL ã‹ã‚‰ update ã‚’è¡Œã†éš›ã«æ–‡å­—åˆ—ä»¥å¤–ã®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›¸ãæ›ãˆã‚‰ã‚Œã¾ã›ã‚“ã€‚GitHub ä¸Šã«ã‚ã‚‹ãƒªãƒã‚¸ãƒˆãƒªã§ã¯ä¿®æ­£ãŒå…¥ã£ã¦ã„ã‚‹ã®ã§ã™ãŒã€Docker ã‚¤ãƒ¡ãƒ¼ã‚¸ã«é©å¿œã•ã‚Œã¦ã„ãªã„ã®ã§å¿…è¦ãªå‡¦ç†ã¨ãªã‚Šã¾ã™ã€‚

# æœ€åˆã«ç”¨æ„ã—ã¦ãŠããƒ¦ãƒ¼ã‚¶ç®¡ç†ç”¨ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«

ä»¥ä¸‹ã€ãƒ¦ãƒ¼ã‚¶ç®¡ç†ç”¨ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™

- supabase/migrations/20220418113839_create_user.sql

```sql
CREATE OR REPLACE FUNCTION public.handle_users_update()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
  begin
    IF (TG_OP = 'DELETE') THEN
      delete from public."User" where id=old.id;
      return old;
    ELSEIF (TG_OP = 'UPDATE') THEN
      update public."User"
        set email=NEW.email,raw_user_meta_data=NEW.raw_user_meta_data where id=old.id;
      return new;
    ELSEIF (TG_OP = 'INSERT') THEN
      insert into public."User"(id, email,raw_user_meta_data) values(NEW.id,NEW.email,NEW.raw_user_meta_data);
      return new;
    END IF;
    return NULL;
  end;

$BODY$;

ALTER FUNCTION public.handle_users_update()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_users_update() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_users_update() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_users_update() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_users_update() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_users_update() TO service_role;

CREATE TABLE IF NOT EXISTS public."User"
(
    id uuid NOT NULL,
    email character varying(255) COLLATE pg_catalog."default",
    raw_user_meta_data text,
    CONSTRAINT "User_pkey" PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."User"
    OWNER to postgres;

ALTER TABLE IF EXISTS public."User"
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public."User" TO anon;

GRANT ALL ON TABLE public."User" TO authenticated;

GRANT ALL ON TABLE public."User" TO postgres;

GRANT ALL ON TABLE public."User" TO service_role;
CREATE POLICY "Enable access to all users"
    ON public."User"
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE trigger on_auth_user_update
  AFTER INSERT OR UPDATE OR DELETE ON auth.users
  for each row execute procedure public.handle_users_update();
```

`auth.users`ã¸ã®æ“ä½œã‚’ãƒ•ãƒƒã‚¯ã—ã¦ã€`public.User`ã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚ã“ã†ã—ã¦ãŠãã¨ã€GraphQL ã®ã‚¹ã‚­ãƒ¼ãƒžãƒ¼ãŒãƒ¦ãƒ¼ã‚¶æƒ…å ±ã¸ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

# Todo ã‚¢ãƒ—ãƒªç”¨ã®ãƒ†ãƒ¼ãƒ–ãƒ«

ã‚¿ã‚¤ãƒˆãƒ«ã€èª¬æ˜Žã€æ—¥æ™‚ã€éžå…¬é–‹å±žæ€§ã€ãƒ¦ãƒ¼ã‚¶æƒ…å ±ã‚’è¨˜æ†¶ã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶æƒ…å ±ã¯ public.User ã«ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¼µã‚Šã¾ã™ã€‚auth.users ã§ã¯ç„¡ã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

```sql
CREATE TABLE IF NOT EXISTS public."Todo"
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid NOT NULL DEFAULT auth.uid(),
    title text COLLATE pg_catalog."default",
    published boolean NOT NULL DEFAULT false,
    description text COLLATE pg_catalog."default",
    CONSTRAINT "Todo_pkey" PRIMARY KEY (id),
    CONSTRAINT "Todo_user_id_fkey" FOREIGN KEY (user_id)
        REFERENCES public."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."Todo"
    OWNER to postgres;

ALTER TABLE IF EXISTS public."Todo"
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public."Todo" TO anon;

GRANT ALL ON TABLE public."Todo" TO authenticated;

GRANT ALL ON TABLE public."Todo" TO postgres;

GRANT ALL ON TABLE public."Todo" TO service_role;
CREATE POLICY "Enable INSERT for authenticated users only"
    ON public."Todo"
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text) and auth.uid() = user_id);
CREATE POLICY "Enable access to all users"
    ON public."Todo"
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (published or auth.uid() = user_id);
CREATE POLICY "Enable DELETE for users based on user_id"
    ON public."Todo"
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Enable UPDATE for users based on user_id"
    ON public."Todo"
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = user_id));
```

Todo ãƒ†ãƒ¼ãƒ–ãƒ«ã¯`CREATE POLICY`ã§ PostgreSQL ã® RLS(è¡Œãƒ¬ãƒ™ãƒ«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)ã‚’ä½œã£ã¦ã„ã¾ã™ã€‚

- Enable access to all users  
  select ã®åˆ¶é™ã§ private ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä¸€è‡´ã—ãªã„ã¨ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã•ãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã®è¨­å®šã‚’å…¥ã‚Œã¦ãŠãã¨éžå…¬é–‹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™
- Enable INSERT for authenticated users only  
  èªè¨¼ãƒ¦ãƒ¼ã‚¶ã®ã¿æ›¸ãè¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸæ›¸ãè¾¼ã‚“ã ãƒ¦ãƒ¼ã‚¶ãŒè©ç§°ã§ããªã„ã‚ˆã†ã«ã€å®Ÿéš›ã®ãƒ¦ãƒ¼ã‚¶ã¨æ›¸ãè¾¼ã¾ã‚Œã‚‹ id ãŒä¸€è‡´ã—ã¦ã„ã‚‹ã‹æ¤œæŸ»ã—ã¦ã„ã¾ã™
- Enable DELETE/UPDATE for users based on user_id  
  ãƒ¦ãƒ¼ã‚¶ãŒä¸€è‡´ã—ãŸå ´åˆã®ã¿ã€æ›¸ãæ›ãˆã¨å‰Šé™¤ã‚’è¨±å¯ã—ã¦ã„ã¾ã™

ã“ã®ã‚ãŸã‚Šã®è¨­å®šã¯æ…£ã‚ŒãŒå¿…è¦ã§ã™ã€‚

# DB ã®ãƒªã‚»ãƒƒãƒˆ

è¿½åŠ ã—ãŸãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©å¿œã•ã›ã‚‹ãŸã‚ã«ã€ã„ã£ãŸã‚“ DB ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚

```sh
supabase db reset
```

# å®Ÿé¨“ç”¨ User ã®ç”¨æ„

èªè¨¼ã«å¿…è¦ãªãƒ¦ãƒ¼ã‚¶ã‚’ä½œæˆã—ã¾ã™ã€‚cli ã§ã¯ç”¨æ„ã•ã‚Œã¦ã„ãªã„ã®ã§è‡ªåˆ†ã§ä½œã‚Šã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ã®ä½œæˆã«ã¯ service_role ã®æ–¹ã®ã‚­ãƒ¼ã‚’ä½¿ã„ã¾ã™ã€‚ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ã‚’ã•ãã£ã¨ä½œã‚ŠãŸã„ã®ã§æ‹›å¾…æ©Ÿèƒ½ã¯ä½¿ã„ã¾ã›ã‚“ã€‚

- .env.local

```sh
NEXT_PUBLIC_SUPABASE_URL=http://localhost:54321
NEXT_PUBLIC_SUPABASE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24ifQ.625_WdcF3KHqz5amU0x2X5WWHP-OEs_4qj0ssLNHzTs
SUPABASE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6InNlcnZpY2Vfcm9sZSJ9.vI9obAHOGyVVKa3pD--kJlyxp-Z2zV9UUMAhKpNLAcU
```

- bin/create-user.ts

```ts
import { createClient } from "@supabase/supabase-js";
import { config } from "dotenv";

const { parsed } = config({ path: ".env.local" });

const endpoint = parsed?.NEXT_PUBLIC_SUPABASE_URL;
const key = parsed?.SUPABASE_KEY;

const createUser = async ({
  email,
  password,
}: {
  email: string;
  password: string;
}) => {
  const supabase = createClient(endpoint!, key!);
  const result = await supabase.auth.api.createUser({
    email,
    password,
    email_confirm: true,
    user_metadata: { name: email },
  });
  return result;
};

(async () => {
  if (!endpoint || !key || process.argv.length < 4) {
    console.log("create-user [email] [password]");
  } else {
    let result;
    for (let i = 0; i < 3; i++) {
      result = await createUser({
        email: process.argv[2],
        password: process.argv[3],
      });
      if (result.error?.status !== 500) break;
    }
    console.log(result);
  }
})();
```

- ãƒ¦ãƒ¼ã‚¶ä½œæˆ  
  `yarn ts-node -s bin/create-user a@example.com a`
  `yarn ts-node -s bin/create-user b@example.com b`

ãŸã¾ã« 500 ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™æ™‚ãŒã‚ã‚‹ã®ã§ 3 å›žãƒªãƒˆãƒ©ã‚¤ã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã¨ã‚Šã‚ãˆãšãƒ†ã‚¹ãƒˆç”¨ãƒ¦ãƒ¼ã‚¶ã‚’äºŒäººä½œã£ã¦ãŠãã¾ã™ã€‚
ä½œæˆã—ãŸãƒ¦ãƒ¼ã‚¶ã®èªè¨¼ã¨ token ã®å—ã‘å–ã‚Šã¯ GraphQL ã§ã¯ã§ããªã„ã®ã§ RestAPI ã‚’ç›´ã«ãŸãŸãã‹`supabase.auth.signIn`ã‚’ä½¿ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

NEXT_PUBLIC_SUPABASE_URL ã¨ SUPABASE_KEY ã‚’ãƒªãƒ¢ãƒ¼ãƒˆã®ã‚‚ã®ã«æ›¸ãæ›ãˆã‚Œã°ã€æœ¬ç•ªç’°å¢ƒç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚
