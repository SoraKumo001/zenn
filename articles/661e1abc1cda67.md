---
title: "urql で GraphQL のデータをコンポーネント上の hook のみで SSR する"
emoji: "🐥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [urql, nextjs, typescript, apollo]
published: false
---

# [Next.js] urql で GraphQL のデータをコンポーネント上の hook のみで SSR する

# Next.js の SSR は面倒くさい

外部から取ってきた非同期データをレンダリングする場合、クライアント専用ならばコンポーネント内に hook を置いて、そのデータを表示する処理を加えれば簡単に記述できます。しかし SSR で初期 HTML に非同期データを加えようと思うと、一気に面倒になります。

何故面倒なのかと言えば、Next.js の初期レンダリングは非同期に対応していなかったからです。そのため、一般的な方法で SSR をやろうとすると`getInitialProps`や`getServerSideProps`を使って非同期データを収集し、コンポーネントにデータを引き渡す流れになります。

この構成の問題点は、クライアントで再フェッチが必要になったときに、サーバ側とクライアント側で別々に処理を書かなければならないことです。

クライアント側に載せた非同期データ取得の hook が、そのままサーバ側で動いてくれればと思ったことはありませんか？先ほど「Next.js の初期レンダリングは非同期に対応していなかった」と書きました。つまり過去形です。実は現在の Next.js(13 系)は React18 対応と共に非同期レンダリングが可能になっています。

# Next.js の非同期レンダリング

Next.js で非同期レンダリングの基本は`throw promise`です。これによって非同期データが解決されるまで、レンダリングをやり直すことが出来ます。ちなみに SSR の初期レンダリング中に`throw promise`コンポーネントを`Suspense`で囲むと SSR-Streaming になってしまい、特殊な HTML+JavaScript 必須コードが出力されてしまうので、今回は使いません。実はこの二つはセットで使うことが必須の機能ではないのです。

# サンプル

- src/pages/index.tsx

Upload の部分は別の記事で使っている部分なので気にしないでください。重要なのは`useQuery`です。これ、何の変哲もありません。完全にいつも通りです。Next.js+urql の組み合わせでよく使われる`withUrqlClient`もいりません。

```tsx
import { gql, useMutation, useQuery } from "urql";

// Date retrieval
const QUERY = gql`
  query date {
    date
  }
`;

// Uploading files
const UPLOAD = gql`
  mutation Upload($file: Upload!) {
    upload(file: $file) {
      name
      type
      value
    }
  }
`;

const Page = () => {
  const [{ data }, refetch] = useQuery({ query: QUERY });
  const [{ data: file }, upload] = useMutation(UPLOAD);

  return (
    <>
      <a
        target="_blank"
        href="https://github.com/SoraKumo001/next-apollo-server"
        rel="noreferrer"
      >
        Source code
      </a>
      <hr />
      {/* SSRedacted data can be updated by refetch. */}
      <button onClick={() => refetch({ requestPolicy: "network-only" })}>
        Update date
      </button> {/* Dates are output as SSR. */}
      {data?.date &&
        new Date(data.date).toLocaleString("en-US", { timeZone: "UTC" })}
      {/* File upload sample from here down. */}
      <div
        style={{
          height: "100px",
          width: "100px",
          background: "lightgray",
          marginTop: "8px",
          padding: "8px",
        }}
        onDragOver={(e) => {
          e.preventDefault();
        }}
        onDrop={(e) => {
          const file = e.dataTransfer.files[0];
          if (file) {
            upload({ file });
          }
          e.preventDefault();
        }}
      >
        Upload Area
      </div>
      {/* Display of information on returned file data to check upload operation. */}
      {file && <pre>{JSON.stringify(file, undefined, "  ")}</pre>}
    </>
  );
};

export default Page;
```

- src/pages/\_app.tsx

ファイルアップロード用に`multipartFetchExchange`とか使ってますが、その部分は気にしないでください。

今回重要なのは`createNextSSRExchange`と`NextSSRProvider`です。`createNextSSRExchange`は、urql 標準の ssrExchange を魔改造して、`throw promise`で発生したデータを初期レンダリングし、クライアントに持ち越せるようにしました。この Exchange を含めるだけで、魔法のようにコンポーネントに載せた hook が SSR の対象になります。

```tsx
import { multipartFetchExchange } from "@urql/exchange-multipart-fetch";
import { useMemo, useState } from "react";
import { cacheExchange, Client, Provider } from "urql";
import { createNextSSRExchange, NextSSRProvider } from "../libs/urql-ssr";
import type { AppType } from "next/app";

const isServerSide = typeof window === "undefined";
const endpoint = "/api/graphql";
const url = isServerSide
  ? `${
      process.env.VERCEL_URL
        ? `https://${process.env.VERCEL_URL}`
        : "http://localhost:3000"
    }${endpoint}`
  : endpoint;

const App: AppType = ({ Component, pageProps }) => {
  // Creation of `Exchange`.
  const [nextSSRExchange] = useState(createNextSSRExchange);
  const client = useMemo(() => {
    return new Client({
      url,
      fetchOptions: {
        headers: {
          // Required for `Upload`.
          "apollo-require-preflight": "true",
        },
      },
      // Only on the Server side do 'throw promise'.
      suspense: isServerSide,
      exchanges: [cacheExchange, nextSSRExchange, multipartFetchExchange],
    });
  }, [nextSSRExchange]);

  return (
    <Provider value={client}>
      {/* Additional data collection functions for SSR */}
      <NextSSRProvider>
        <Component {...pageProps} />
      </NextSSRProvider>
    </Provider>
  );
};

// Create getInitialProps that do nothing to prevent Next.js optimisation.
App.getInitialProps = () => ({});

export default App;
```

- src/libs/urql-ssr.tsx

SSR 用 Exchange の中身は以下のようになります。
・`throw promise`の待機処理
・収集したデータを HTML に出力する処理
・クライアント側でキャッシュに載せる処理

urql を使い始めて三日しか経っていない状態で書いたコードなので、綺麗に直してから npm に登録する予定です。

```tsx
import { ReactNode } from "react";
import {
  composeExchanges,
  Exchange,
  makeResult,
  OperationResult,
  ssrExchange,
  useClient,
} from "urql";

import { pipe, tap, filter, merge, mergeMap, fromPromise } from "wonka";

type Promises = Set<Promise<void>>;
const DATA_NAME = "__NEXT_DATA_PROMISE__";
const isServerSide = typeof window === "undefined";

/**
 * Collecting data from HTML
 */
export const getInitialState = () => {
  if (typeof window !== "undefined") {
    const node = document.getElementById(DATA_NAME);
    if (node) return JSON.parse(node.innerHTML);
  }
  return undefined;
};

/**
 * Wait until end of Query and output collected data at render time
 */
const DataRender = () => {
  const client = useClient();
  if (isServerSide) {
    const extractData = client.readQuery(`query{extractData}`, {})?.data
      .extractData;
    if (!extractData) {
      throw client.query(`query{extractData}`, {}).toPromise();
    }
    return (
      <script
        id={DATA_NAME}
        type="application/json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(extractData) }}
      />
    );
  }
  return null;
};

/**
 * For SSR data insertion
 */
export const NextSSRProvider = ({ children }: { children: ReactNode }) => {
  return (
    <>
      {children}
      <DataRender />
    </>
  );
};

/**
 * local query function
 */
const createLocalValueExchange = <T extends object>(
  key: string,
  callback: () => Promise<T>
) => {
  const localValueExchange: Exchange = (input) => {
    const { forward } = input;
    return (operation) => {
      const filterOps$ = pipe(
        operation,
        filter((op) => {
          const definition = op.query.definitions[0];
          if (definition?.kind === "OperationDefinition") {
            const selection = definition.selectionSet.selections[0];
            if (selection?.kind === "Field") {
              if (selection.name.value === key) return false;
            }
          }
          return true;
        }),
        forward
      );
      const valueOps$ = pipe(
        operation,
        mergeMap((op) => {
          const source = fromPromise(
            new Promise<OperationResult>(async (resolve) => {
              resolve(makeResult(op, { data: { [key]: await callback() } }));
            })
          );
          return source;
        })
      );
      return merge([filterOps$, valueOps$]);
    };
  };
  return localValueExchange;
};

/**
 * Query standby extensions
 */
export const createNextSSRExchange = () => {
  const promises: Promises = new Set();

  const _ssrExchange = ssrExchange({
    isClient: !isServerSide,
    // Set up initial data required for SSR
    initialState: getInitialState(),
  });
  const _nextExchange: Exchange = (input) => {
    const { forward } = input;
    return (operation) => {
      if (!isServerSide) {
        return forward(operation);
      } else {
        return pipe(
          operation,
          tap((op) => {
            if (op.kind === "query") {
              const promise = new Promise<void>((resolve) => {
                op.context.resolve = resolve;
              });
              promises.add(promise);
            }
          }),
          forward,
          tap((op) => {
            if (op.operation.kind === "query") {
              op.operation.context.resolve();
            }
          })
        );
      }
    };
  };
  return composeExchanges(
    [
      _ssrExchange,
      isServerSide &&
        createLocalValueExchange("extractData", async () => {
          let length: number;
          while ((length = promises?.size)) {
            await Promise.allSettled(promises).then(() => {
              if (length === promises.size) {
                promises.clear();
              }
            });
          }
          return _ssrExchange.extractData();
        }),
      _nextExchange,
    ].filter((v): v is Exchange => v !== false)
  );
};
```
