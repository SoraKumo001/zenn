---
title: "[Next.js] urql ã§ GraphQL ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä¸Šã® hook ã®ã¿ã§ SSR"
emoji: "ğŸ¥"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [urql, nextjs, typescript, apollo]
published: true
---

# Next.js ã® SSR ã¯é¢å€’ãã•ã„

SSR ã‚’è€ƒãˆãªã„å ´åˆã€å¤–éƒ¨ã‹ã‚‰å–ã£ã¦ããŸéåŒæœŸãƒ‡ãƒ¼ã‚¿ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã¯ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã«å–å¾—å‡¦ç†ã‚’ç½®ã„ã¦ã€å—ã‘å–ã‚ŒãŸæ™‚ç‚¹ã§ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã¨ã„ã†æµã‚Œã§æ¯”è¼ƒçš„ç°¡å˜ã«è¨˜è¿°ã§ãã¾ã™ã€‚ã—ã‹ã— SSR ã§åˆæœŸ HTML ã«éåŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’åŠ ãˆã‚ˆã†ã¨æ€ã†ã¨ã€ä¸€æ°—ã«é¢å€’ã«ãªã‚Šã¾ã™ã€‚

ä½•æ•…é¢å€’ãªã®ã‹ã¨è¨€ãˆã°ã€Next.js ã®åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã¯éåŒæœŸã«å¯¾å¿œã—ã¦ã„ãªã‹ã£ãŸã‹ã‚‰ã§ã™ã€‚ãã®ãŸã‚ã€ä¸€èˆ¬çš„ãªæ–¹æ³•ã§ SSR ã‚’ã‚„ã‚ã†ã¨ã™ã‚‹ã¨`getInitialProps`ã‚„`getServerSideProps`ã‚’ä½¿ã£ã¦éåŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’åé›†ã—ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ãæ¸¡ã™æµã‚Œã«ãªã‚Šã¾ã™ã€‚

ã“ã®æ§‹æˆã®å•é¡Œç‚¹ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§å†ãƒ•ã‚§ãƒƒãƒãŒå¿…è¦ã«ãªã£ãŸã¨ãã«ã€ã‚µãƒ¼ãƒå´ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§åˆ¥ã€…ã«å‡¦ç†ã‚’æ›¸ã‹ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã§ã™ã€‚

# å®Ÿã¯å¯èƒ½ã«ãªã£ã¦ã„ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå´ã‹ã‚‰ã® SSR ãƒ‡ãƒ¼ã‚¿ä½œæˆ

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã«è¼‰ã›ãŸéåŒæœŸãƒ‡ãƒ¼ã‚¿å–å¾—å‡¦ç†ãŒã€ãã®ã¾ã¾ã‚µãƒ¼ãƒå´ã§å‹•ã„ã¦ãã‚Œã‚Œã°ã¨æ€ã£ãŸã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã‹ï¼Ÿå…ˆã»ã©ã€ŒNext.js ã®åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã¯éåŒæœŸã«å¯¾å¿œã—ã¦ã„ãªã‹ã£ãŸã€ã¨æ›¸ãã¾ã—ãŸã€‚ã¤ã¾ã‚Šéå»å½¢ã§ã™ã€‚å®Ÿã¯ç¾åœ¨ã® Next.js(13 ç³»)ã¯ React18 å¯¾å¿œã¨å…±ã«éåŒæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãŒå¯èƒ½ã«ãªã£ã¦ã„ã¾ã™ã€‚

# `throw promise`ã¨`Suspense`ã®é–¢ä¿‚

Next.js ã§éåŒæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®åŸºæœ¬ã¯`throw promise`ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦éåŒæœŸãƒ‡ãƒ¼ã‚¿ãŒè§£æ±ºã•ã‚Œã‚‹ã¾ã§ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’ã‚„ã‚Šç›´ã™ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ã¡ãªã¿ã« SSR ã®åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­ã«`throw promise`ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’`Suspense`ã§å›²ã‚€ã¨ SSR-Streaming ã«ãªã£ã¦ã—ã¾ã„ã€ç‰¹æ®Šãª HTML+JavaScript å¿…é ˆã‚³ãƒ¼ãƒ‰ãŒå‡ºåŠ›ã•ã‚Œã¦ã—ã¾ã†ã®ã§ã€ä»Šå›ã¯ä½¿ã„ã¾ã›ã‚“ã€‚å®Ÿã¯ã“ã®äºŒã¤ã¯ã‚»ãƒƒãƒˆã§ä½¿ã†ã“ã¨ãŒå¿…é ˆã®æ©Ÿèƒ½ã§ã¯ãªã„ã®ã§ã™ã€‚

# ã‚µãƒ³ãƒ—ãƒ«

## å†…å®¹

GraphQL ã§æ—¥ä»˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã€ãã®å†…å®¹ã‚’ SSR ã§å‡ºåŠ›ã—ã¦ã„ã¾ã™ã€‚ã“ã®å¾Œã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã‚‚ã‚‰ãˆã‚Œã°åˆ†ã‹ã‚Šã¾ã™ãŒã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã®`useQuery`ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå°‚ç”¨ã«æ›¸ãå ´åˆã¨åŒã˜æ›¸ãæ–¹ã§ã™ã€‚

## å‹•ä½œç¢ºèªç”¨ URL

https://next-urql.vercel.app/

## å‹•ä½œç”»é¢

å˜ç´”ã«æ—¥ä»˜ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã ã‘ã®ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€SSR ã§åˆæœŸ HTML ã®ä¸­ã«æ—¥ä»˜ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€ JavaScript ã‚’åˆ‡ã£ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒªãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã£ãŸå ´åˆã‚‚è¡¨ç¤ºå†…å®¹ã¯æ—¥ä»˜ãŒè¡¨ç¤ºã•ã‚ŒãŸçŠ¶æ…‹ã¨ãªã‚Šã¾ã™ã€‚

![](/images/661e1abc1cda67/2023-01-09-20-05-12.png)

ä»¥ä¸‹ãŒåˆæœŸ HTML ã®å†…å®¹ã§ã™ã€‚æ—¥ä»˜è¡¨ç¤ºç”¨ã®ã‚¿ã‚°ã¨ã€ã‚µãƒ¼ãƒå´ã§ç”Ÿæˆã—ãŸ urql ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å¼•ãæ¸¡ã™ãŸã‚ã®ãƒ‡ãƒ¼ã‚¿ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã®å¼•ãæ¸¡ã—ã¯ ServerComponents+ClientComponents ã®çµ„ã¿åˆã‚ã›ã‚’ä½¿ã†ã¨è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ã®ã§ã™ãŒã€ãã®æ§‹æˆã¯ä¸ä¾¿ãªç‚¹ãŒå¤šã™ãã‚‹ãŸã‚ã€ä»Šå›ä½œã£ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªå´ã§å¼•ãæ¸¡ã—å‡¦ç†ã‚’ç”Ÿæˆã—ã¦ã„ã¾ã™ã€‚ã¨ã„ã†ã“ã¨ã§ ServerComponents ã¯ä½¿ã£ã¦ã„ã¾ã›ã‚“ã€‚

![](/images/661e1abc1cda67/2023-01-09-21-06-14.png)

## ä»Šå›ä½œã£ãŸæ©Ÿèƒ½ã‚’ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åŒ–ã—ãŸã‚‚ã®

ãã®éç¨‹ã§ä»¥ä¸‹ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ npm ã«ç™»éŒ²ã—ã¾ã—ãŸã€‚

https://www.npmjs.com/package/@react-libraries/next-exchange-ssr

## ã‚³ãƒ¼ãƒ‰ã®å†…å®¹

- src/pages/index.tsx

Upload ã®éƒ¨åˆ†ã¯åˆ¥ã®è¨˜äº‹ã§ä½¿ã£ã¦ã„ã‚‹éƒ¨åˆ†ãªã®ã§æ°—ã«ã—ãªã„ã§ãã ã•ã„ã€‚é‡è¦ãªã®ã¯`useQuery`ã§ã™ã€‚ã“ã‚Œã€ä½•ã®å¤‰å“²ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚SSR ã‚’æ„è­˜ã™ã‚‹å¿…è¦ã¯ç„¡ãã€å®Œå…¨ã«ã„ã¤ã‚‚é€šã‚Šã§ã™ã€‚Next.js+urql ã®çµ„ã¿åˆã‚ã›ã§ã‚ˆãä½¿ã‚ã‚Œã‚‹`withUrqlClient`ã‚‚ã„ã‚Šã¾ã›ã‚“ã€‚

```tsx
import { gql, useMutation, useQuery } from "urql";

// Date retrieval
const QUERY = gql`
  query date {
    date
  }
`;

// Uploading files
const UPLOAD = gql`
  mutation Upload($file: Upload!) {
    upload(file: $file) {
      name
      type
      value
    }
  }
`;

const Page = () => {
  const [{ data }, refetch] = useQuery({ query: QUERY });
  const [{ data: file }, upload] = useMutation(UPLOAD);

  return (
    <>
      <a
        target="_blank"
        href="https://github.com/SoraKumo001/next-apollo-server"
        rel="noreferrer"
      >
        Source code
      </a>
      <hr />
      {/* SSRedacted data can be updated by refetch. */}
      <button onClick={() => refetch({ requestPolicy: "network-only" })}>
        Update date
      </button> {/* Dates are output as SSR. */}
      {data?.date &&
        new Date(data.date).toLocaleString("en-US", { timeZone: "UTC" })}
      {/* File upload sample from here down. */}
      <div
        style={{
          height: "100px",
          width: "100px",
          background: "lightgray",
          marginTop: "8px",
          padding: "8px",
        }}
        onDragOver={(e) => {
          e.preventDefault();
        }}
        onDrop={(e) => {
          const file = e.dataTransfer.files[0];
          if (file) {
            upload({ file });
          }
          e.preventDefault();
        }}
      >
        Upload Area
      </div>
      {/* Display of information on returned file data to check upload operation. */}
      {file && <pre>{JSON.stringify(file, undefined, "  ")}</pre>}
    </>
  );
};

export default Page;
```

- src/pages/\_app.tsx

ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ã«`multipartFetchExchange`ã¨ã‹ä½¿ã£ã¦ã¾ã™ãŒã€ãã®éƒ¨åˆ†ã¯æ°—ã«ã—ãªã„ã§ãã ã•ã„ã€‚

ä»Šå›é‡è¦ãªã®ã¯`createNextSSRExchange`ã¨`NextSSRProvider`ã§ã™ã€‚`createNextSSRExchange`ã¯ã€urql æ¨™æº–ã® ssrExchange ã‚’æ‹¡å¼µã—ãŸã‚‚ã®ã§ã™ã€‚`throw promise`ã§ç™ºç”Ÿã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æŒã¡è¶Šã›ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚ã“ã® Exchange ã‚’å«ã‚ã‚‹ã ã‘ã§ã€é­”æ³•ã®ã‚ˆã†ã«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«è¼‰ã›ãŸ hook ãŒ SSR ã®å¯¾è±¡ã«ãªã‚Šã¾ã™ã€‚

ã‚µãƒ¼ãƒã§å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æŒã¡è¶Šã™ãŸã‚ã«`NextSSRProvider`ã‚‚å¿…è¦ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã‚’å…¥ã‚Œç„¡ãã¦ã‚‚ SSR è‡ªä½“ã¯è¡Œãˆã‚‹ã®ã§ã™ãŒã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã§ urql ã®åˆæœŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒç©ºçŠ¶æ…‹ã§å§‹ã¾ã£ã¦ã—ã¾ã†ã®ã§ã€ãƒ‡ãƒ¼ã‚¿ã‚’ fetch ã™ã‚‹å‡¦ç†ãŒå‹•ã„ã¦ã—ã¾ã„ã¾ã™ã€‚

ã¾ãŸã€`getInitialProps`è‡ªä½“ã¯ä½¿ã£ã¦ã„ãªã„ã®ã§ã™ãŒã€ã“ã‚Œã‚’å…¥ã‚Œã¦ãŠã‹ãªã„ã¨\_app.tsx ãŒãƒ“ãƒ«ãƒ‰æ™‚ã«é™çš„ã«ä½œã‚‰ã‚Œã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¢ã‚¯ã‚»ã‚¹æ™‚ã«å†å®Ÿè¡Œã•ã‚Œãªããªã‚‹ã®ã§ã€æœ€é©åŒ–é˜²æ­¢ã®ãŸã‚ã«å¿…è¦ã«ãªã‚Šã¾ã™ã€‚

```tsx
import {
  createNextSSRExchange,
  NextSSRProvider,
} from "@react-libraries/next-exchange-ssr";
import { multipartFetchExchange } from "@urql/exchange-multipart-fetch";
import { useMemo, useState } from "react";
import { cacheExchange, Client, Provider } from "urql";
import type { AppType } from "next/app";

const isServerSide = typeof window === "undefined";
const endpoint = "/api/graphql";
const url = isServerSide
  ? `${
      process.env.VERCEL_URL
        ? `https://${process.env.VERCEL_URL}`
        : "http://localhost:3000"
    }${endpoint}`
  : endpoint;

const App: AppType = ({ Component, pageProps }) => {
  // NextSSRExchange to be unique on AppTree
  const [nextSSRExchange] = useState(createNextSSRExchange);

  const client = useMemo(() => {
    return new Client({
      url,
      fetchOptions: {
        headers: {
          //// Required for `Upload`.
          "apollo-require-preflight": "true",
          //// When authenticating, the useMemo callback is re-executed and the cache is destroyed.
          //'authorization': `Bearer ${token}`
        },
      },
      // Only on the Server side do 'throw promise'.
      suspense: isServerSide,
      exchanges: [cacheExchange, nextSSRExchange, multipartFetchExchange],
    });
  }, [nextSSRExchange /*,token*/]);

  return (
    <Provider value={client}>
      {/* Additional data collection functions for SSR */}
      <NextSSRProvider>
        <Component {...pageProps} />
      </NextSSRProvider>
    </Provider>
  );
};

// Create getInitialProps that do nothing to prevent Next.js optimisation.
App.getInitialProps = () => ({});

export default App;
```

- @urql/exchange-multipart-fetch

ã“ã¡ã‚‰ã¯ã€ä»Šå›ä½œã£ãŸ Exchange ã‚’ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åŒ–ã—ãŸã‚‚ã®ã§ã™ã€‚
SSR ç”¨ Exchange ã®ä¸­èº«ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
ãƒ»`throw promise`ã®å¾…æ©Ÿå‡¦ç†
ãƒ»åé›†ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ HTML ã«å‡ºåŠ›ã™ã‚‹å‡¦ç†
ãƒ»ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«è¼‰ã›ã‚‹å‡¦ç†

```tsx
import { DocumentNode } from "graphql";
import { createElement, Fragment, ReactNode } from "react";
import {
  AnyVariables,
  composeExchanges,
  Exchange,
  makeResult,
  OperationResult,
  ssrExchange,
  TypedDocumentNode,
  useClient,
} from "urql";

import { pipe, tap, filter, merge, mergeMap, fromPromise } from "wonka";

type Promises = Set<Promise<void>>;
const DATA_NAME = "__NEXT_DATA_PROMISE__";
const isServerSide = typeof window === "undefined";

/**
 * Collecting data from HTML
 */
export const getInitialState = () => {
  if (typeof window !== "undefined") {
    const node = document.getElementById(DATA_NAME);
    if (node) return JSON.parse(node.innerHTML);
  }
  return undefined;
};

/**
 * Wait until end of Query and output collected data at render time
 */
const DataRender = () => {
  const client = useClient();
  if (isServerSide) {
    const extractData = client.readQuery(`query{extractData}`, {})?.data
      .extractData;
    if (!extractData) {
      throw client.query(`query{extractData}`, {}).toPromise();
    }
    return createElement("script", {
      id: DATA_NAME,
      type: "application/json",
      dangerouslySetInnerHTML: { __html: JSON.stringify(extractData) },
    });
  }
  return null;
};

/**
 * For SSR data insertion
 */
export const NextSSRProvider = ({ children }: { children: ReactNode }) => {
  return createElement(Fragment, {}, children, createElement(DataRender));
};

/**
 * Get name from first field
 */
const getFieldSelectionName = (
  query: DocumentNode | TypedDocumentNode<any, AnyVariables>
) => {
  const definition = query.definitions[0];
  if (definition?.kind === "OperationDefinition") {
    const selection = definition.selectionSet.selections[0];
    if (selection?.kind === "Field") {
      return selection.name.value;
    }
  }
  return undefined;
};

/**
 * local query function
 */
const createLocalValueExchange = <T extends object>(
  key: string,
  callback: () => Promise<T>
) => {
  const localValueExchange: Exchange = ({ forward }) => {
    return (ops$) => {
      const filterOps$ = pipe(
        ops$,
        filter(({ query }) => {
          const selectionName = getFieldSelectionName(query);
          return key !== selectionName;
        }),
        forward
      );
      const valueOps$ = pipe(
        ops$,
        mergeMap((op) => {
          return fromPromise(
            new Promise<OperationResult>(async (resolve) => {
              resolve(makeResult(op, { data: { [key]: await callback() } }));
            })
          );
        })
      );
      return merge([filterOps$, valueOps$]);
    };
  };
  return localValueExchange;
};

/**
 * Query standby extensions
 */
export const createNextSSRExchange = () => {
  const promises: Promises = new Set();

  const _ssrExchange = ssrExchange({
    isClient: !isServerSide,
    // Set up initial data required for SSR
    initialState: getInitialState(),
  });
  const _nextExchange: Exchange = ({ forward }) => {
    return (ops$) => {
      if (!isServerSide) {
        return forward(ops$);
      } else {
        return pipe(
          ops$,
          tap(({ kind, context }) => {
            if (kind === "query") {
              const promise = new Promise<void>((resolve) => {
                context.resolve = resolve;
              });
              promises.add(promise);
            }
          }),
          forward,
          tap(({ operation }) => {
            if (operation.kind === "query") {
              operation.context.resolve();
            }
          })
        );
      }
    };
  };
  return composeExchanges(
    [
      _ssrExchange,
      isServerSide &&
        createLocalValueExchange("extractData", async () => {
          let length: number;
          while ((length = promises?.size)) {
            await Promise.allSettled(promises).then(() => {
              if (length === promises.size) {
                promises.clear();
              }
            });
          }
          return _ssrExchange.extractData();
        }),
      _nextExchange,
    ].filter((v): v is Exchange => v !== false)
  );
};
```

# ã¾ã¨ã‚

`throw promise`ã¯`Suspense`ã¨ã‚»ãƒƒãƒˆã«ã—ãŸã‚Šã€`ServerComponents`ã‚„`SSR Streaming`ã§ä½¿ã‚ã‚Œã‚‹ã‚‚ã®ã¨ã„ã†èªè­˜ãŒåºƒã¾ã£ã¦ã„ã¾ã™ã€‚ã—ã‹ã—é€šå¸¸ã® SSR ã‚’è¡Œã†å ´åˆã§ã‚ã£ã¦ã‚‚ã€åˆ©ä¾¿æ€§ã®é«˜ã„éåŒæœŸãƒ‡ãƒ¼ã‚¿å¾…ã¡æ©Ÿèƒ½ã¨ã—ã¦ä½¿ãˆã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹å‡¦ç†ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ»ã‚µãƒ¼ãƒç”¨ã«äºŒé‡ã«æ›¸ãå¿…è¦ãŒãªãã€2 ãƒ‘ã‚¹ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚‚å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä¸Šã«ã„ã¤ã‚‚é€šã‚Šã‚¯ã‚¨ãƒªã‚’é…ç½®ã™ã‚Œã°ã€SSR æ™‚ã®å‡¦ç†ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®å‡¦ç†ã‚’åŒæ™‚ã‹ã¤è‡ªç„¶ã«æ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚‹ã®ã§ã¨ã¦ã‚‚ä¾¿åˆ©ã§ã™ã€‚
