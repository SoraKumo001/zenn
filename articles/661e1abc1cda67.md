---
title: "urql ã§ GraphQL ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä¸Šã® hook ã®ã¿ã§ SSR ã™ã‚‹"
emoji: "ğŸ¥"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [urql, nextjs, typescript, apollo]
published: false
---

# [Next.js] urql ã§ GraphQL ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä¸Šã® hook ã®ã¿ã§ SSR ã™ã‚‹

# Next.js ã® SSR ã¯é¢å€’ãã•ã„

å¤–éƒ¨ã‹ã‚‰å–ã£ã¦ããŸéåŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹å ´åˆã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå°‚ç”¨ãªã‚‰ã°ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã« hook ã‚’ç½®ã„ã¦ã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã™ã‚‹å‡¦ç†ã‚’åŠ ãˆã‚Œã°ç°¡å˜ã«è¨˜è¿°ã§ãã¾ã™ã€‚ã—ã‹ã— SSR ã§åˆæœŸ HTML ã«éåŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’åŠ ãˆã‚ˆã†ã¨æ€ã†ã¨ã€ä¸€æ°—ã«é¢å€’ã«ãªã‚Šã¾ã™ã€‚

ä½•æ•…é¢å€’ãªã®ã‹ã¨è¨€ãˆã°ã€Next.js ã®åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã¯éåŒæœŸã«å¯¾å¿œã—ã¦ã„ãªã‹ã£ãŸã‹ã‚‰ã§ã™ã€‚ãã®ãŸã‚ã€ä¸€èˆ¬çš„ãªæ–¹æ³•ã§ SSR ã‚’ã‚„ã‚ã†ã¨ã™ã‚‹ã¨`getInitialProps`ã‚„`getServerSideProps`ã‚’ä½¿ã£ã¦éåŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’åé›†ã—ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ãæ¸¡ã™æµã‚Œã«ãªã‚Šã¾ã™ã€‚

ã“ã®æ§‹æˆã®å•é¡Œç‚¹ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§å†ãƒ•ã‚§ãƒƒãƒãŒå¿…è¦ã«ãªã£ãŸã¨ãã«ã€ã‚µãƒ¼ãƒå´ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§åˆ¥ã€…ã«å‡¦ç†ã‚’æ›¸ã‹ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã§ã™ã€‚

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã«è¼‰ã›ãŸéåŒæœŸãƒ‡ãƒ¼ã‚¿å–å¾—ã® hook ãŒã€ãã®ã¾ã¾ã‚µãƒ¼ãƒå´ã§å‹•ã„ã¦ãã‚Œã‚Œã°ã¨æ€ã£ãŸã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã‹ï¼Ÿå…ˆã»ã©ã€ŒNext.js ã®åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã¯éåŒæœŸã«å¯¾å¿œã—ã¦ã„ãªã‹ã£ãŸã€ã¨æ›¸ãã¾ã—ãŸã€‚ã¤ã¾ã‚Šéå»å½¢ã§ã™ã€‚å®Ÿã¯ç¾åœ¨ã® Next.js(13 ç³»)ã¯ React18 å¯¾å¿œã¨å…±ã«éåŒæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãŒå¯èƒ½ã«ãªã£ã¦ã„ã¾ã™ã€‚

# Next.js ã®éåŒæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°

Next.js ã§éåŒæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®åŸºæœ¬ã¯`throw promise`ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦éåŒæœŸãƒ‡ãƒ¼ã‚¿ãŒè§£æ±ºã•ã‚Œã‚‹ã¾ã§ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’ã‚„ã‚Šç›´ã™ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ã¡ãªã¿ã« SSR ã®åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­ã«`throw promise`ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’`Suspense`ã§å›²ã‚€ã¨ SSR-Streaming ã«ãªã£ã¦ã—ã¾ã„ã€ç‰¹æ®Šãª HTML+JavaScript å¿…é ˆã‚³ãƒ¼ãƒ‰ãŒå‡ºåŠ›ã•ã‚Œã¦ã—ã¾ã†ã®ã§ã€ä»Šå›ã¯ä½¿ã„ã¾ã›ã‚“ã€‚å®Ÿã¯ã“ã®äºŒã¤ã¯ã‚»ãƒƒãƒˆã§ä½¿ã†ã“ã¨ãŒå¿…é ˆã®æ©Ÿèƒ½ã§ã¯ãªã„ã®ã§ã™ã€‚

# ã‚µãƒ³ãƒ—ãƒ«

- src/pages/index.tsx

Upload ã®éƒ¨åˆ†ã¯åˆ¥ã®è¨˜äº‹ã§ä½¿ã£ã¦ã„ã‚‹éƒ¨åˆ†ãªã®ã§æ°—ã«ã—ãªã„ã§ãã ã•ã„ã€‚é‡è¦ãªã®ã¯`useQuery`ã§ã™ã€‚ã“ã‚Œã€ä½•ã®å¤‰å“²ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚å®Œå…¨ã«ã„ã¤ã‚‚é€šã‚Šã§ã™ã€‚Next.js+urql ã®çµ„ã¿åˆã‚ã›ã§ã‚ˆãä½¿ã‚ã‚Œã‚‹`withUrqlClient`ã‚‚ã„ã‚Šã¾ã›ã‚“ã€‚

```tsx
import { gql, useMutation, useQuery } from "urql";

// Date retrieval
const QUERY = gql`
  query date {
    date
  }
`;

// Uploading files
const UPLOAD = gql`
  mutation Upload($file: Upload!) {
    upload(file: $file) {
      name
      type
      value
    }
  }
`;

const Page = () => {
  const [{ data }, refetch] = useQuery({ query: QUERY });
  const [{ data: file }, upload] = useMutation(UPLOAD);

  return (
    <>
      <a
        target="_blank"
        href="https://github.com/SoraKumo001/next-apollo-server"
        rel="noreferrer"
      >
        Source code
      </a>
      <hr />
      {/* SSRedacted data can be updated by refetch. */}
      <button onClick={() => refetch({ requestPolicy: "network-only" })}>
        Update date
      </button> {/* Dates are output as SSR. */}
      {data?.date &&
        new Date(data.date).toLocaleString("en-US", { timeZone: "UTC" })}
      {/* File upload sample from here down. */}
      <div
        style={{
          height: "100px",
          width: "100px",
          background: "lightgray",
          marginTop: "8px",
          padding: "8px",
        }}
        onDragOver={(e) => {
          e.preventDefault();
        }}
        onDrop={(e) => {
          const file = e.dataTransfer.files[0];
          if (file) {
            upload({ file });
          }
          e.preventDefault();
        }}
      >
        Upload Area
      </div>
      {/* Display of information on returned file data to check upload operation. */}
      {file && <pre>{JSON.stringify(file, undefined, "  ")}</pre>}
    </>
  );
};

export default Page;
```

- src/pages/\_app.tsx

ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ã«`multipartFetchExchange`ã¨ã‹ä½¿ã£ã¦ã¾ã™ãŒã€ãã®éƒ¨åˆ†ã¯æ°—ã«ã—ãªã„ã§ãã ã•ã„ã€‚

ä»Šå›é‡è¦ãªã®ã¯`createNextSSRExchange`ã¨`NextSSRProvider`ã§ã™ã€‚`createNextSSRExchange`ã¯ã€urql æ¨™æº–ã® ssrExchange ã‚’é­”æ”¹é€ ã—ã¦ã€`throw promise`ã§ç™ºç”Ÿã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æŒã¡è¶Šã›ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚ã“ã® Exchange ã‚’å«ã‚ã‚‹ã ã‘ã§ã€é­”æ³•ã®ã‚ˆã†ã«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«è¼‰ã›ãŸ hook ãŒ SSR ã®å¯¾è±¡ã«ãªã‚Šã¾ã™ã€‚

```tsx
import { multipartFetchExchange } from "@urql/exchange-multipart-fetch";
import { useMemo, useState } from "react";
import { cacheExchange, Client, Provider } from "urql";
import { createNextSSRExchange, NextSSRProvider } from "../libs/urql-ssr";
import type { AppType } from "next/app";

const isServerSide = typeof window === "undefined";
const endpoint = "/api/graphql";
const url = isServerSide
  ? `${
      process.env.VERCEL_URL
        ? `https://${process.env.VERCEL_URL}`
        : "http://localhost:3000"
    }${endpoint}`
  : endpoint;

const App: AppType = ({ Component, pageProps }) => {
  // Creation of `Exchange`.
  const [nextSSRExchange] = useState(createNextSSRExchange);
  const client = useMemo(() => {
    return new Client({
      url,
      fetchOptions: {
        headers: {
          // Required for `Upload`.
          "apollo-require-preflight": "true",
        },
      },
      // Only on the Server side do 'throw promise'.
      suspense: isServerSide,
      exchanges: [cacheExchange, nextSSRExchange, multipartFetchExchange],
    });
  }, [nextSSRExchange]);

  return (
    <Provider value={client}>
      {/* Additional data collection functions for SSR */}
      <NextSSRProvider>
        <Component {...pageProps} />
      </NextSSRProvider>
    </Provider>
  );
};

// Create getInitialProps that do nothing to prevent Next.js optimisation.
App.getInitialProps = () => ({});

export default App;
```

- src/libs/urql-ssr.tsx

SSR ç”¨ Exchange ã®ä¸­èº«ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
ãƒ»`throw promise`ã®å¾…æ©Ÿå‡¦ç†
ãƒ»åé›†ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ HTML ã«å‡ºåŠ›ã™ã‚‹å‡¦ç†
ãƒ»ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«è¼‰ã›ã‚‹å‡¦ç†

urql ã‚’ä½¿ã„å§‹ã‚ã¦ä¸‰æ—¥ã—ã‹çµŒã£ã¦ã„ãªã„çŠ¶æ…‹ã§æ›¸ã„ãŸã‚³ãƒ¼ãƒ‰ãªã®ã§ã€ç¶ºéº—ã«ç›´ã—ã¦ã‹ã‚‰ npm ã«ç™»éŒ²ã™ã‚‹äºˆå®šã§ã™ã€‚

```tsx
import { ReactNode } from "react";
import {
  composeExchanges,
  Exchange,
  makeResult,
  OperationResult,
  ssrExchange,
  useClient,
} from "urql";

import { pipe, tap, filter, merge, mergeMap, fromPromise } from "wonka";

type Promises = Set<Promise<void>>;
const DATA_NAME = "__NEXT_DATA_PROMISE__";
const isServerSide = typeof window === "undefined";

/**
 * Collecting data from HTML
 */
export const getInitialState = () => {
  if (typeof window !== "undefined") {
    const node = document.getElementById(DATA_NAME);
    if (node) return JSON.parse(node.innerHTML);
  }
  return undefined;
};

/**
 * Wait until end of Query and output collected data at render time
 */
const DataRender = () => {
  const client = useClient();
  if (isServerSide) {
    const extractData = client.readQuery(`query{extractData}`, {})?.data
      .extractData;
    if (!extractData) {
      throw client.query(`query{extractData}`, {}).toPromise();
    }
    return (
      <script
        id={DATA_NAME}
        type="application/json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(extractData) }}
      />
    );
  }
  return null;
};

/**
 * For SSR data insertion
 */
export const NextSSRProvider = ({ children }: { children: ReactNode }) => {
  return (
    <>
      {children}
      <DataRender />
    </>
  );
};

/**
 * local query function
 */
const createLocalValueExchange = <T extends object>(
  key: string,
  callback: () => Promise<T>
) => {
  const localValueExchange: Exchange = (input) => {
    const { forward } = input;
    return (operation) => {
      const filterOps$ = pipe(
        operation,
        filter((op) => {
          const definition = op.query.definitions[0];
          if (definition?.kind === "OperationDefinition") {
            const selection = definition.selectionSet.selections[0];
            if (selection?.kind === "Field") {
              if (selection.name.value === key) return false;
            }
          }
          return true;
        }),
        forward
      );
      const valueOps$ = pipe(
        operation,
        mergeMap((op) => {
          const source = fromPromise(
            new Promise<OperationResult>(async (resolve) => {
              resolve(makeResult(op, { data: { [key]: await callback() } }));
            })
          );
          return source;
        })
      );
      return merge([filterOps$, valueOps$]);
    };
  };
  return localValueExchange;
};

/**
 * Query standby extensions
 */
export const createNextSSRExchange = () => {
  const promises: Promises = new Set();

  const _ssrExchange = ssrExchange({
    isClient: !isServerSide,
    // Set up initial data required for SSR
    initialState: getInitialState(),
  });
  const _nextExchange: Exchange = (input) => {
    const { forward } = input;
    return (operation) => {
      if (!isServerSide) {
        return forward(operation);
      } else {
        return pipe(
          operation,
          tap((op) => {
            if (op.kind === "query") {
              const promise = new Promise<void>((resolve) => {
                op.context.resolve = resolve;
              });
              promises.add(promise);
            }
          }),
          forward,
          tap((op) => {
            if (op.operation.kind === "query") {
              op.operation.context.resolve();
            }
          })
        );
      }
    };
  };
  return composeExchanges(
    [
      _ssrExchange,
      isServerSide &&
        createLocalValueExchange("extractData", async () => {
          let length: number;
          while ((length = promises?.size)) {
            await Promise.allSettled(promises).then(() => {
              if (length === promises.size) {
                promises.clear();
              }
            });
          }
          return _ssrExchange.extractData();
        }),
      _nextExchange,
    ].filter((v): v is Exchange => v !== false)
  );
};
```
