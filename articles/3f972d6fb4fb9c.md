---
title: "WebAssemblyã¨WebWorkerã§ä½œã‚‹ãƒ–ãƒ©ã‚¦ã‚¶ã§å‹•ãWebPã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼"
emoji: "ğŸ˜"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [wasm, webp, nextjs, react, typescript]
published: true
---

â€»[ã“ã¡ã‚‰](https://next-blog.croud.jp/contents/fwS6jQIb215HUlJKiC54)ã§ã‚‚åŒã˜è¨˜äº‹ã‚’æ›¸ã„ã¦ã„ã¾ã™

# WebP ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã®å¿…è¦æ€§

Web ä¸Šã§ä½¿ã‚ã‚Œã‚‹ç”»åƒå½¢å¼ã¨ã—ã¦ WebP ã®åˆ©ç”¨é »åº¦ãŒä¸ŠãŒã£ã¦ã„ã¾ã™ã€‚ãã®ä»–ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¯¾ã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºçš„ã«æœ‰åˆ©ã«åƒãã‹ã‚‰ã§ã™ã€‚ã‚ˆãè¡Œã‚ã‚Œã‚‹ã®ã¯ã€ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸç”»åƒã‚’ã‚µãƒ¼ãƒå´ã§ WebP ã«å¤‰æ›ã—ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é…ä¿¡ã•ã‚Œã‚‹ã¨ã„ã†æµã‚Œã§ã™ã€‚ã—ã‹ã—æ ¹æœ¬çš„ã«è€ƒãˆã‚‹ã¨ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹å‰ã« WebP ã«ã—ã¦ã—ã¾ãˆã°ã€ã„ã‚ã„ã‚ãªç„¡é§„ãŒçœã‘ã¾ã™ã€‚ã¨ã„ã†ã“ã¨ã§ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‰ã«ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã§ WebP ã«å¤‰æ›ã™ã‚Œã°å•é¡Œè§£æ±ºã§ã™ã€‚

# ãƒ–ãƒ©ã‚¦ã‚¶ã§ WebP ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’ã™ã‚‹ã«ã¯

ãƒ–ãƒ©ã‚¦ã‚¶ã®æ¨™æº–æ©Ÿèƒ½ã ã¨ WebP ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã¯å¯èƒ½ã§ã™ãŒã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹æ©Ÿèƒ½ã¯ Chrome ã ã‘ã«ã—ã‹å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šæ±ç”¨çš„ãªå¯¾å¿œã‚’è€ƒãˆãŸå ´åˆã€ãã®æ©Ÿèƒ½ã¯è‡ªåˆ†ã§ä½•ã¨ã‹ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

https://github.com/webmproject/libwebp

ã“ã¡ã‚‰ã« webp ã‚’æ‰±ã†ãŸã‚ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã‚Šã€C è¨€èªã‹ã‚‰ wasm ã§å‡ºåŠ›ã‚‚å‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã®ã§åˆ©ç”¨ã—ã¾ã™ã€‚ã“ã®éš›ã«å¿…è¦ã«ãªã‚‹ã®ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ã™ã€‚

# wasm ã‚’å‡ºåŠ›ã™ã‚‹ C ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©

emsdk ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™

https://emscripten.org/docs/getting_started/downloads.html

emcc ã‚³ãƒãƒ³ãƒ‰ãŒé€šã‚‹ã‚ˆã†ã«ãªã‚Œã° OK ã§ã™

# WebP ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã®ä½œã‚Šæ–¹

ã“ã¡ã‚‰ã«ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒè¼‰ã£ã¦ã„ã¾ã™

https://developer.mozilla.org/ja/docs/WebAssembly/existing_C_to_wasm

ã“ã‚Œã‚’å…ƒã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã„ã¦ã¿ã¾ã™

# WebP ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã‚’ C++ã§æ›¸ã

## ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä½œæˆ

- src/webp.cpp

```cpp
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include "src/webp/encode.h"

using namespace emscripten;

val encode(std::string img_in, int width, int height, float quality) {
  uint8_t* img_out;
  size_t size = WebPEncodeRGBA((uint8_t*)img_in.c_str(), width, height, width * 4, quality, &img_out);
  val result = size ? val::global("Uint8Array").new_(typed_memory_view(size, img_out)) : val::null();
  WebPFree(img_out);
  return result;
}

EMSCRIPTEN_BINDINGS(my_module) {
  function("encode", &encode);
}
```

ã‚µãƒ³ãƒ—ãƒ«ã¯ C è¨€èªã§æ›¸ã‹ã‚Œã¦ã„ã¾ã—ãŸãŒã€bind ã¨ val ã‚’ä½¿ã†ãŸã‚ã« C++ã«ç›´ã—ã¦ã„ã¾ã™ã€‚ã“ã¡ã‚‰ã®æ–¹æ³•ã‚’ä½¿ã†ã¨ã€ãƒªã‚½ãƒ¼ã‚¹ã®ç®¡ç†ã‚„é–¢æ•°ã‚³ãƒ¼ãƒ‰ã® JavaScript ã¸ã®å¼•ãç¶™ããŒç°¡å˜ã«è¡Œãˆã¾ã™ã€‚

## ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«

- Makefile

```Makefile
SHELL=/bin/bash
webp: src/webp.cpp
	emcc -O3 --bind -msimd128 \
    -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 -s ENVIRONMENT=web,worker -s EXPORT_ES6=1 -s DYNAMIC_EXECUTION=0 -s MODULARIZE=1 \
    -I libwebp src/webp.cpp -o dist/webp.js \
    libwebp/src/{dsp,enc,utils}/*.c
```

å¿…è¦ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨­å®šã—ã¦ emcc ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’ã‹ã‘ã¾ã™ã€‚SIMD å¯¾å¿œã«ã—ã¦ libwebp ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰å¿…è¦ãªéƒ¨åˆ†ã®ã¿ã‚’ãƒãƒ§ã‚¤ã‚¹ã—ã¦ã„ã¾ã™ã€‚  
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’è¡Œã†ã¨ã€`webp.wasm`ã¨`webp.js`ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚

## TypeScript ã®å‹ã‚’ä½œæˆ

- src/webp.d.ts

```ts
export declare type ModuleType = {
  encode: (
    data: BufferSource,
    width: number,
    height: number,
    quality: number
  ) => Uint8Array | null;
};
declare const webp: () => Promise<ModuleType>;
export default webp;
```

TypeScript ã‹ã‚‰å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«å‹ã‚’ä½œã‚Šã¾ã™ã€‚

## å®Œæˆ

å˜ç´”ã« WebP ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’è¡Œã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã—ã¦ãªã‚‰ã“ã‚Œã§å®Œæˆã§ã™

```ts
import webp from "./webp";

webp().then(({ encode }) => {
  const result = encode(arrayBuffer, width, height); //ç”»åƒãƒ‡ãƒ¼ã‚¿,å¹…,é«˜ã•
});
```

ã®ã‚ˆã†ãªå½¢ã§å‘¼ã³å‡ºã™ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚
ãŸã ã“ã‚Œã ã¨ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®å‡¦ç†ãŒè¡Œã‚ã‚Œã‚‹ã®ã§ã€ãã®é–“ã¯å‡¦ç†ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œ UI ãŒæ­¢ã¾ã‚Šã¾ã™ã€‚

# WebWorker ã®åˆ©ç”¨

é‡ã„å‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹ã¨ãã«å½¹ç«‹ã¤ã®ãŒ WebWorker ã§ã™ã€‚åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‡¦ç†ã§ãã‚‹ã®ã§ã€ãã®é–“ã«ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒæ­¢ã¾ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¨ã„ã†ã“ã¨ã§ WebWorker åŒ–ã—ã¦ã„ãã¾ã™ã€‚

https://www.npmjs.com/package/worker-lib

ã“ã¡ã‚‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã‚’ä½¿ã†ã¨ Worker ã®å‡¦ç†ã‚’æ™®é€šã®éåŒæœŸå‡¦ç†ã¨åŒã˜ã‚ˆã†ã«æ›¸ãã“ã¨ãŒå‡ºæ¥ã¦ä¾¿åˆ©ã§ã™ã€‚

- src/worker.ts

```ts
import { initWorker } from "worker-lib";
import webp, { ModuleType } from "./webp.js";

let webpModule: ModuleType;

const getModule = async () => {
  if (!webpModule) webpModule = await webp();
  return webpModule;
};
const encode = async (
  data: BufferSource,
  width: number,
  height: number,
  quality: number
): Promise<Uint8Array | null> => {
  return (await getModule()).encode(data, width, height, quality);
};

// Initialization process to make it usable in Worker.
const map = initWorker({ encode });
// Export only the type
export type WorkerWebp = typeof map;
```

åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§å‡¦ç†ã™ã‚‹æ©Ÿèƒ½ã‚’ä½œã‚Šã¾ã™ã€‚

- src/index.ts

```ts
import { createWorker } from "worker-lib";
import type { WorkerWebp } from "./worker.js";

const execute = createWorker<WorkerWebp>(
  () => new Worker(new URL("./worker", import.meta.url)),
  4 // Maximum parallel number
);

export const encode: {
  (
    data: BufferSource,
    width: number,
    height: number,
    quality?: number
  ): Promise<Uint8Array | null>;
  (data: ImageData, quality?: number): Promise<Uint8Array | null>;
} = async (
  data: BufferSource | ImageData,
  a?: number,
  b?: number,
  c?: number
) => {
  return data instanceof ImageData
    ? execute("encode", data.data, data.width, data.height, a || 100)
    : execute("encode", data, a as number, b as number, c || 100);
};

export default true;
```

å…ˆã»ã©ä½œã£ãŸæ©Ÿèƒ½ã‚’å‘¼ã³å‡ºã™éƒ¨åˆ†ã«ãªã‚Šã¾ã™ã€‚`createWorker`ã§ WebWorker ã®å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³ãŒä½œæˆã•ã‚Œã€æŒ‡å®šã—ãŸæœ€å¤§æ•°ã ã‘ä¸¦åˆ—ã§å‡¦ç†ã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚ä»Šå›ã¯ä¸¦åˆ—æ•° 4 ã«ã—ã¦ã‚ã‚Šã¾ã™ã€‚`encode`ã¯å¼•æ•°ã®å†…å®¹ã«å¿œã˜ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒ¯ã‚Šåˆ†ã‘ã¦ã„ã¾ã™ã€‚

# å®Œæˆã€webp ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€

ã“ã¡ã‚‰ã« npm ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åŒ–ã—ãŸã‚‚ã®ã‚’ç™»éŒ²ã—ã¾ã—ãŸã€‚

https://www.npmjs.com/package/@node-libraries/wasm-webp-encoder

ä¸€é€£ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ã“ã¡ã‚‰ã§ã™

https://github.com/node-libraries/wasm-webp-encoder

# å®Ÿéš›ã«ä½¿ã£ã¦ã¿ã‚‹

Next.js ã§ç”»åƒã‚’ WebP ã«å¤‰æ›ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã£ã¦ã¿ã¾ã™ã€‚

- ç”»åƒã®ãƒ‰ãƒ©ãƒƒã‚°ãƒ‰ãƒ­ãƒƒãƒ—
- ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å†…ã®ç”»åƒè²¼ã‚Šä»˜ã‘
- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ

ä»¥ä¸Šã®ä¸‰ç¨®é¡ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ–¹æ³•ã«å¯¾å¿œã•ã›ã¾ã—ãŸã€‚å—ã‘å–ã£ãŸç”»åƒã‚’ WebP ã«å¤‰æ›ã—ã¦è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚

è¡¨ç¤ºã•ã‚ŒãŸç”»åƒã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ WebP å½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚

- ã‚µãƒ³ãƒ—ãƒ«ã‚½ãƒ¼ã‚¹

https://github.com/SoraKumo001/next-webp

- Vercel ã§ã®å‹•ä½œç¢ºèª

https://next-webp.vercel.app/

- src/pages/index.tsx

```tsx
import React, { FC, useEffect, useRef, useState } from "react";
import { encode } from "@node-libraries/wasm-webp-encoder";
import styled from "./index.module.scss";

export const classNames = (...classNames: (string | undefined | false)[]) =>
  classNames.reduce(
    (a, b, index) => a + (b ? (index ? " " : "") + b : ""),
    ""
  ) as string | undefined;

export const convertWebp = async (blob: Blob) => {
  if (!blob.type.match(/^image\/(png|jpeg)/)) return blob;
  const src = await blob
    .arrayBuffer()
    .then(
      (v) => `data:${blob.type};base64,` + Buffer.from(v).toString("base64")
    );
  const img = document.createElement("img");
  img.src = src;
  await new Promise((resolve) => (img.onload = resolve));
  const canvas = document.createElement("canvas");
  [canvas.width, canvas.height] = [img.width, img.height];
  const ctx = canvas.getContext("2d")!;
  ctx.drawImage(img, 0, 0);
  const value = await encode(ctx.getImageData(0, 0, img.width, img.height));
  if (!value) return null;
  return new Blob([value], { type: "image/webp" });
};

const Page = () => {
  const ref = useRef<HTMLInputElement>(null);
  const [isDrag, setDrag] = useState(false);
  const [imageData, setImageData] = useState<string | undefined>();
  const convertUrl = async (blob: Blob | undefined | null) => {
    if (!blob) return undefined;
    return (
      `data:image/webp;base64,` +
      Buffer.from(await blob.arrayBuffer()).toString("base64")
    );
  };
  useEffect(() => {
    const handle = () => {
      navigator.clipboard.read().then((items) => {
        for (const item of items) {
          item.getType("image/png").then(async (value) => {
            const v = await convertWebp(value);
            convertUrl(v).then(setImageData);
          });
        }
      });
    };
    addEventListener("paste", handle);
    return () => removeEventListener("paste", handle);
  }, []);
  return (
    <div
      className={classNames(styled.root, isDrag && styled.dragover)}
      onDragOver={(e) => {
        e.preventDefault();
        e.stopPropagation();
      }}
      onClick={(e) => {
        ref.current?.click();
        e.stopPropagation();
      }}
      onDragEnter={() => setDrag(true)}
      onDragLeave={() => setDrag(false)}
      onDrop={(e) => {
        for (const item of e.dataTransfer.files) {
          convertWebp(item).then((blob) => {
            convertUrl(blob).then(setImageData);
          });
        }
        e.preventDefault();
      }}
    >
      {imageData ? (
        <>
          <span
            className={styled.clear}
            onClick={() => {
              setImageData(undefined);
            }}
          >
            âœ–
          </span>
          <img
            src={imageData}
            onClick={() => {
              const node = document.createElement("a");
              node.download = "download.webp";
              node.href = imageData;
              node.click();
            }}
          />
        </>
      ) : (
        <>
          <input
            ref={ref}
            type="file"
            accept=".jpg, .png, .gif"
            onChange={(e) => {
              const blob = e.currentTarget.files?.[0];
              if (blob) {
                convertUrl(blob).then(setImageData);
              }
            }}
          />
        </>
      )}
    </div>
  );
};
export default Page;
```

å—ã‘å–ã£ãŸç”»åƒã‚’ Canvas ã§å±•é–‹ã—ã¦ã‹ã‚‰ã€WebP ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã§å¤‰æ›ã—ã¾ã™ã€‚convertWebp ã¯ç„¡é§„ã« Blob ã«å¤‰æ›ã—ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€ä»–ã®ç”¨é€”ã‚’è€ƒãˆã¦ã“ã†ãªã£ã¦ã„ã¾ã™ã€‚

# ã¾ã¨ã‚

WebAssembly ã¨ WebWorker ã¯ã“ã†ã„ã†ç”¨é€”ä»¥å¤–ã ã¨ãªã‹ãªã‹ä½¿ã†æ©Ÿä¼šãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ»…å¤šã«ä½¿ã‚ãªã„ã‚‚ã®ã ã¨ã€å¿…è¦ã«ãªã£ãŸã¨ãã«è…°ãŒé‡ããªã‚ŠãŒã¡ã§ã™ã€‚ã—ã‹ã—å®Ÿéš›ã«ã‚„ã£ã¦ã¿ã‚‹ã¨ãã†é›£ã—ã„ã‚‚ã®ã§ã¯ãªã„ã®ã§ã€å¿…è¦ã«ãªã£ãŸã‚‰ã‚µã‚¯ãƒƒã¨ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã£ã¦ãŠãã¨é¸æŠã®å¹…ãŒåºƒãŒã‚Šã¾ã™ã€‚
