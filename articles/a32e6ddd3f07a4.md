---
title: "[TypeScript]10個までのオーバーロードされた関数型から引数の型や返り値の型を共用体で取り出す方法"
emoji: "🐥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [typescript,javascript]
published: true
---

こちらの記事を参考にしています。

https://zenn.dev/uhyo/articles/typescript-overload-infer


# 10個までのオーバーロードに対応した戻り値の型を取得

10個までのオーバーロードに対応した戻り値の型を返却する型を作成してみました。

```ts
type OverloadReturnType<T> = T extends
  {
    (...args: any): infer R,
    (...args: any): infer R,
    (...args: any): infer R,
    (...args: any): infer R,
    (...args: any): infer R,
    (...args: any): infer R,
    (...args: any): infer R,
    (...args: any): infer R,
    (...args: any): infer R,
    (...args: any): infer R,
  }
  ? R : never

// 以下、使い方

const niceFunc: {
  (arg: string): { [key: string]: string };
  (arg: boolean): boolean;
  (arg: number): string;
  (arg: string): number;
} = (arg) => {
  return arg as never //dummy
}

type Func = typeof niceFunc;

// number
type Ret = ReturnType<Func>;
// string | number | boolean | {[key: string]: string;}
type Ret2 = OverloadReturnType<Func>;
```

`Ret2`は`string | number | boolean | {[key: string]: string;}`になっています


ちなみに同様方法で引数型を取り出そうとすると交差型で取得してしまうので、使いどころの無い状態になりました。引数まで本気でやろうとすると元記事のuhyoさんがおっしゃるとおり力業しかないようです。


# 10個までのオーバーロードに対応したパラメータ型を取得する

これが力業です。

```ts
type OverloadParameters1<T> = T extends
    {
        (...args: infer P1): infer R1,
    }
    ? [P1, R1] : never

type OverloadParameters2<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
    }
    ? [P1, R1] | [P2, R2] : never

type OverloadParameters3<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
        (...args: infer P3): infer R3,
    }
    ? [P1, R1] | [P2, R2] | [P3, R3] : never

type OverloadParameters4<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
        (...args: infer P3): infer R3,
        (...args: infer P4): infer R4,
    }
    ? [P1, R1] | [P2, R2] | [P3, R3] | [P4, R4] : never

type OverloadParameters5<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
        (...args: infer P3): infer R3,
        (...args: infer P4): infer R4,
        (...args: infer P5): infer R5,
    }
    ? [P1, R1] | [P2, R2] | [P3, R3] | [P4, R4] | [P5, R5] : never

type OverloadParameters6<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
        (...args: infer P3): infer R3,
        (...args: infer P4): infer R4,
        (...args: infer P5): infer R5,
        (...args: infer P6): infer R6,
    }
    ? [P1, R1] | [P2, R2] | [P3, R3] | [P4, R4] | [P5, R5] | [P6, R6] : never

type OverloadParameters7<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
        (...args: infer P3): infer R3,
        (...args: infer P4): infer R4,
        (...args: infer P5): infer R5,
        (...args: infer P6): infer R6,
        (...args: infer P7): infer R7,
    }
    ? [P1, R1] | [P2, R2] | [P3, R3] | [P4, R4] | [P5, R5] | [P6, R6] | [P7, R7] : never

type OverloadParameters8<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
        (...args: infer P3): infer R3,
        (...args: infer P4): infer R4,
        (...args: infer P5): infer R5,
        (...args: infer P6): infer R6,
        (...args: infer P7): infer R7,
        (...args: infer P8): infer R8,
    }
    ? [P1, R1] | [P2, R2] | [P3, R3] | [P4, R4] | [P5, R5] | [P6, R6] | [P7, R7] | [P8, R8] : never

type OverloadParameters9<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
        (...args: infer P3): infer R3,
        (...args: infer P4): infer R4,
        (...args: infer P5): infer R5,
        (...args: infer P6): infer R6,
        (...args: infer P7): infer R7,
        (...args: infer P8): infer R8,
        (...args: infer P9): infer R9,
    }
    ? [P1, R1] | [P2, R2] | [P3, R3] | [P4, R4] | [P5, R5] | [P6, R6] | [P7, R7] | [P8, R8] | [P9, R9] : never

type OverloadParameters10<T> = T extends
    {
        (...args: infer P1): infer R1,
        (...args: infer P2): infer R2,
        (...args: infer P3): infer R3,
        (...args: infer P4): infer R4,
        (...args: infer P5): infer R5,
        (...args: infer P6): infer R6,
        (...args: infer P7): infer R7,
        (...args: infer P8): infer R8,
        (...args: infer P9): infer R9,
        (...args: infer P10): infer R10,
    }
    ? [P1, R1] | [P2, R2] | [P3, R3] | [P4, R4] | [P5, R5] | [P6, R6] | [P7, R7] | [P8, R8] | [P9, R9] | [P10, R10] : never

type OverloadFunction<T> =
    any extends OverloadParameters10<T> ? OverloadParameters10<T> :
    any extends OverloadParameters9<T> ? OverloadParameters9<T> :
    any extends OverloadParameters8<T> ? OverloadParameters8<T> :
    any extends OverloadParameters7<T> ? OverloadParameters7<T> :
    any extends OverloadParameters6<T> ? OverloadParameters6<T> :
    any extends OverloadParameters5<T> ? OverloadParameters5<T> :
    any extends OverloadParameters4<T> ? OverloadParameters4<T> :
    any extends OverloadParameters3<T> ? OverloadParameters3<T> :
    any extends OverloadParameters2<T> ? OverloadParameters2<T> :
    any extends OverloadParameters1<T> ? OverloadParameters1<T> :
    never

type OverloadParameters<T> = OverloadFunction<T>[0]

// 以下、使い方

const niceFunc: {
    (arg: string): { [key: string]: string };
    (arg: boolean): boolean;
    (arg: number): string;
    (arg: string): number;
} = (arg) => {
    return arg as never //dummy
}
type Func = typeof niceFunc;

//[[arg: string], {[key: string]: string;}] | [[arg: boolean], boolean] | [[arg: number], string] | [[arg: string], number]
type FunctionType = OverloadFunction<Func>
//[arg: string]
type Params1 = Parameters<Func>
//[arg: string] | [arg: boolean] | [arg: number] | [arg: string]
type Params2 = OverloadParameters<Func>

```

ということで取り出しに成功しました。`Params2`は`[arg: string] | [arg: boolean] | [arg: number] | [arg: string]`という状態になっています。
`OverloadFunction`の方はパラメータと戻り値の対応関係もそのまま含まれています。

# まとめ

力業は思いつきでざっと実装してみただけなので、もっとエレガントに書く方法があるかもしれません。
